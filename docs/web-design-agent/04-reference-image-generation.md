# Plan 04: Reference Image Generation

> **Purpose:** Implement the reference screenshot generation using Gemini's image generation capability. This creates a visual reference that establishes the design direction without specifying colors.

**Dependencies:** Plan 01 (Infrastructure), Plan 02 (Category Presets)  
**Estimated Time:** 3-4 hours  
**Parallelizable With:** Plan 03

---

## Core Concept

The reference image is a full-page website mockup generated by Gemini. The key insight:

1. **Structure-only prompts**: We specify WHAT sections appear, not HOW they look
2. **No color constraints**: Gemini chooses a creative, category-appropriate palette
3. **Full-page format**: 1440px × 4500-5500px portrait orientation
4. **Later extraction**: Design tokens are extracted FROM this image (Plan 05)

---

## Subtasks

### Type Definitions

- [ ] **4.1** Add reference image types to `src/types/site-generation.ts`

```typescript
export interface ReferenceImageResult {
  imageUrl: string;           // Public URL in Supabase Storage
  prompt: string;             // The prompt that generated it
  generatedAt: string;        // ISO timestamp
  dimensions: {
    width: number;            // 1440
    height: number;           // 4500-5500
  };
}

export interface GenerateReferenceInput {
  jobId: string;
  category: string;
  businessDescriptor?: string;  // Optional override
}
```

### Edge Function Implementation

- [ ] **4.2** Create edge function at `supabase/functions/generate-reference/index.ts`

```typescript
import { GoogleGenerativeAI } from 'https://esm.sh/@google/generative-ai@0.21.0';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders, handleError } from '../_shared/utils.ts';

const genAI = new GoogleGenerativeAI(Deno.env.get('GOOGLE_AI_API_KEY')!);

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const body = await req.json();
    const { jobId, category, businessDescriptor } = body;

    // Get category preset
    const preset = CATEGORY_PRESETS[category];
    if (!preset) {
      return new Response(
        JSON.stringify({ error: `Unknown category: ${category}` }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Build structure-only prompt (no colors!)
    const prompt = buildImagePrompt({
      ...preset,
      businessDescriptor: businessDescriptor || preset.businessDescriptor,
    });

    console.log('Generating reference image with prompt:', prompt.slice(0, 200) + '...');

    // Call Gemini Image model
    const model = genAI.getGenerativeModel({
      model: 'gemini-2.0-flash-exp-image-generation',
    });

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      generationConfig: {
        responseModalities: ['image', 'text'],
      },
    });

    // Extract image from response
    const candidate = result.response.candidates?.[0];
    if (!candidate?.content?.parts) {
      throw new Error('No content in Gemini response');
    }

    const imagePart = candidate.content.parts.find((p: any) =>
      p.inlineData?.mimeType?.startsWith('image/')
    );

    if (!imagePart?.inlineData) {
      throw new Error('No image generated - Gemini may have refused the request');
    }

    // Decode base64 image
    const imageBuffer = Uint8Array.from(
      atob(imagePart.inlineData.data),
      (c) => c.charCodeAt(0)
    );

    // Upload to Supabase Storage
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );

    const fileName = `references/${jobId}-${Date.now()}.png`;
    const { error: uploadError } = await supabase.storage
      .from('site-assets')
      .upload(fileName, imageBuffer, {
        contentType: 'image/png',
        upsert: true,
      });

    if (uploadError) {
      throw new Error(`Storage upload failed: ${uploadError.message}`);
    }

    // Get public URL
    const { data: { publicUrl } } = supabase.storage
      .from('site-assets')
      .getPublicUrl(fileName);

    // Update job record
    await supabase
      .from('site_generations')
      .update({
        reference_image_url: publicUrl,
        status: 'reference-generated',
      })
      .eq('id', jobId);

    return new Response(
      JSON.stringify({
        imageUrl: publicUrl,
        prompt: prompt,
        generatedAt: new Date().toISOString(),
        dimensions: {
          width: 1440,
          height: preset.pageHeight,
        },
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Reference generation error:', error);
    return handleError(error);
  }
});
```

- [ ] **4.3** Add category presets to edge function (copy from shared module)

```typescript
// Include in the same file or import from shared location
interface ImagePromptParams {
  businessDescriptor: string;
  pageHeight: number;
  header: string;
  hero: string;
  sections: string[];
  footer: string;
}

const CATEGORY_PRESETS: Record<string, ImagePromptParams> = {
  'emergency-plumber': {
    businessDescriptor: 'Trusted 24/7 emergency plumbing company',
    pageHeight: 4800,
    header: 'Sticky header with bold logo and prominent emergency phone number',
    hero: 'Full-screen hero with professional plumber at work in modern home, urgent but reassuring headline, "Call Now" and "Get Free Quote" dual CTAs, 24/7 availability badge',
    sections: [
      'Trust bar with response time, completed jobs count, and 5-star rating',
      '6-card emergency services grid: Burst Pipes, Water Heater, Drain Cleaning, Sewer Line, Leak Detection, Fixture Repair with relevant imagery',
      '"Why Choose Us" 4-column section: Licensed, Insured, Fast Response, Upfront Pricing with icons',
      '3 customer testimonial cards with star ratings and emergency repair stories',
      '"How It Works" 3-step process: Call, We Dispatch, Problem Solved with numbered steps',
      'Service area map showing coverage zones',
      'About section with owner photo, license numbers, and certification badges',
      'Bold CTA banner with phone number and "Available 24/7" messaging',
    ],
    footer: '4-column footer with emergency contact, services list, service areas, and licensing info',
  },
  // ... add all other presets from Plan 02
};

function buildImagePrompt(params: ImagePromptParams): string {
  const allSections = [
    params.header,
    params.hero,
    ...params.sections,
    params.footer,
  ].join(' → ');

  return `Full-page website screenshot, portrait orientation, 1440px × ${params.pageHeight}px. ${params.businessDescriptor} landing page, entire page from header to footer in one continuous image.

Sections top to bottom: ${allSections}.`;
}
```

### Frontend Client

- [ ] **4.4** Add reference generation to API client

```typescript
import type { ReferenceImageResult, GenerateReferenceInput } from '../../types/site-generation';

export async function generateReference(
  input: GenerateReferenceInput
): Promise<ReferenceImageResult> {
  const { data, error } = await supabase.functions.invoke('generate-reference', {
    body: input,
  });
  
  if (error) throw error;
  return data as ReferenceImageResult;
}
```

### Retry and Regeneration Logic

- [ ] **4.5** Add retry wrapper with exponential backoff

```typescript
export async function generateReferenceWithRetry(
  input: GenerateReferenceInput,
  maxRetries = 3
): Promise<ReferenceImageResult> {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await generateReference(input);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      console.warn(`Reference generation attempt ${attempt} failed:`, lastError.message);
      
      // Check if it's a rate limit or temporary error
      if (lastError.message.includes('rate limit') || lastError.message.includes('429')) {
        // Longer wait for rate limits
        await new Promise(resolve => setTimeout(resolve, 5000 * attempt));
      } else if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
      }
    }
  }
  
  throw lastError;
}
```

- [ ] **4.6** Add regeneration function (uses new timestamp for unique filename)

```typescript
export async function regenerateReference(
  jobId: string,
  category: string,
  businessDescriptor?: string
): Promise<ReferenceImageResult> {
  // This will create a new image with a new timestamp
  // Old images remain in storage (can clean up later)
  return generateReferenceWithRetry({
    jobId,
    category,
    businessDescriptor,
  });
}
```

### Image Validation

- [ ] **4.7** Add response validation

```typescript
export function validateReferenceResult(data: unknown): ReferenceImageResult {
  if (!data || typeof data !== 'object') {
    throw new Error('Invalid reference result: not an object');
  }
  
  const result = data as Record<string, unknown>;
  
  if (!result.imageUrl || typeof result.imageUrl !== 'string') {
    throw new Error('Invalid reference result: missing imageUrl');
  }
  
  if (!result.imageUrl.startsWith('http')) {
    throw new Error('Invalid reference result: imageUrl is not a valid URL');
  }
  
  return result as unknown as ReferenceImageResult;
}
```

### Storage Cleanup Utility

- [ ] **4.8** Add utility to clean up old reference images

```typescript
export async function cleanupOldReferences(
  jobId: string,
  keepLatest = 1
): Promise<void> {
  const { data: files, error } = await supabase.storage
    .from('site-assets')
    .list(`references`, {
      search: jobId,
      sortBy: { column: 'created_at', order: 'desc' },
    });
  
  if (error || !files) return;
  
  // Keep the latest N files, delete the rest
  const filesToDelete = files.slice(keepLatest);
  
  if (filesToDelete.length > 0) {
    await supabase.storage
      .from('site-assets')
      .remove(filesToDelete.map(f => `references/${f.name}`));
  }
}
```

### Error Handling

- [ ] **4.9** Add specific error types for reference generation

```typescript
export class ReferenceGenerationError extends Error {
  constructor(
    message: string,
    public readonly code: 'RATE_LIMIT' | 'CONTENT_POLICY' | 'API_ERROR' | 'STORAGE_ERROR' | 'UNKNOWN',
    public readonly retryable: boolean
  ) {
    super(message);
    this.name = 'ReferenceGenerationError';
  }
}

export function parseReferenceError(error: unknown): ReferenceGenerationError {
  const message = error instanceof Error ? error.message : String(error);
  
  if (message.includes('rate limit') || message.includes('429')) {
    return new ReferenceGenerationError(message, 'RATE_LIMIT', true);
  }
  
  if (message.includes('refused') || message.includes('policy') || message.includes('safety')) {
    return new ReferenceGenerationError(message, 'CONTENT_POLICY', false);
  }
  
  if (message.includes('storage') || message.includes('upload')) {
    return new ReferenceGenerationError(message, 'STORAGE_ERROR', true);
  }
  
  return new ReferenceGenerationError(message, 'UNKNOWN', true);
}
```

### Progress Tracking

- [ ] **4.10** Add progress event types for UI updates

```typescript
export type ReferenceGenerationProgress =
  | { stage: 'starting'; message: string }
  | { stage: 'generating'; message: string; attempt?: number }
  | { stage: 'uploading'; message: string }
  | { stage: 'complete'; result: ReferenceImageResult }
  | { stage: 'error'; error: ReferenceGenerationError };

export type ReferenceProgressCallback = (progress: ReferenceGenerationProgress) => void;

export async function generateReferenceWithProgress(
  input: GenerateReferenceInput,
  onProgress: ReferenceProgressCallback
): Promise<ReferenceImageResult> {
  onProgress({ stage: 'starting', message: 'Preparing image generation...' });
  
  try {
    onProgress({ stage: 'generating', message: 'Generating reference image with Gemini...' });
    const result = await generateReference(input);
    onProgress({ stage: 'complete', result });
    return result;
  } catch (error) {
    const parsedError = parseReferenceError(error);
    onProgress({ stage: 'error', error: parsedError });
    throw parsedError;
  }
}
```

### Testing

- [ ] **4.11** Create test file for reference generation

```typescript
// src/api/site-generator/__tests__/reference.test.ts
import { describe, it, expect } from 'vitest';
import { validateReferenceResult, parseReferenceError } from '../reference';

describe('Reference Image Generation', () => {
  describe('validateReferenceResult', () => {
    it('validates complete result', () => {
      const valid = {
        imageUrl: 'https://example.com/image.png',
        prompt: 'Full-page website screenshot...',
        generatedAt: new Date().toISOString(),
        dimensions: { width: 1440, height: 4800 },
      };
      
      expect(() => validateReferenceResult(valid)).not.toThrow();
    });
    
    it('rejects missing imageUrl', () => {
      expect(() => validateReferenceResult({ prompt: 'test' })).toThrow();
    });
  });
  
  describe('parseReferenceError', () => {
    it('identifies rate limit errors', () => {
      const error = parseReferenceError(new Error('rate limit exceeded'));
      expect(error.code).toBe('RATE_LIMIT');
      expect(error.retryable).toBe(true);
    });
    
    it('identifies content policy errors', () => {
      const error = parseReferenceError(new Error('content policy violation'));
      expect(error.code).toBe('CONTENT_POLICY');
      expect(error.retryable).toBe(false);
    });
  });
});
```

---

## Verification Checklist

- [ ] Edge function deploys without errors
- [ ] Gemini generates full-page website screenshots
- [ ] Images upload successfully to Supabase Storage
- [ ] Public URLs are accessible
- [ ] Job record updates with image URL
- [ ] Retry logic handles rate limits correctly
- [ ] Regeneration creates new images without breaking existing ones
- [ ] Error messages are descriptive and actionable

---

## Example Output

For category `emergency-plumber`, the function should:

1. Generate this prompt:
```
Full-page website screenshot, portrait orientation, 1440px × 4800px.
Trusted 24/7 emergency plumbing company landing page, entire page from
header to footer in one continuous image.

Sections top to bottom: Sticky header with bold logo and prominent
emergency phone number → Full-screen hero with professional plumber...
```

2. Return:
```json
{
  "imageUrl": "https://xxx.supabase.co/storage/v1/object/public/site-assets/references/abc123-1706234567.png",
  "prompt": "Full-page website screenshot...",
  "generatedAt": "2024-01-25T12:34:56.789Z",
  "dimensions": {
    "width": 1440,
    "height": 4800
  }
}
```

---

## Next Steps

After completing this plan:
1. Proceed to **Plan 05: Design Token Extraction** (analyzes this image)
2. The generated image URL is passed to the extraction step
